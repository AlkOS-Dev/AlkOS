#!/bin/bash

FEATURE_FLAGS_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
FEATURE_FLAGS_PATH="${FEATURE_FLAGS_DIR}/../../config/feature_flags.conf"
FEATURE_FLAGS_DEFS_PATH="${FEATURE_FLAGS_DIR}/../config/feature_flags_defs.yaml"
FEATURE_FLAGS_CXX_PATH="${FEATURE_FLAGS_DIR}/../../alkos/generated/include/autogen/feature_flags.h"

source "${FEATURE_FLAGS_DIR}/helpers.bash"

# --------------------------------------------
# Feature flags generation functionality
# --------------------------------------------

feature_flags_generate_file() {
  echo "#!/bin/bash" > "${FEATURE_FLAGS_PATH}"
  echo "" >> "${FEATURE_FLAGS_PATH}"
  echo "declare -A CONFIGURE_FEATURE_FLAGS" >> "${FEATURE_FLAGS_PATH}"
  echo "" >> "${FEATURE_FLAGS_PATH}"
}

feature_flags_generate_cxx_files_header() {
  echo "// This file is generated by configure script. Do not edit manually." > "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#ifndef GENERATED_INCLUDE_AUTOGEN_H_" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#define GENERATED_INCLUDE_AUTOGEN_H_" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_generate_cxx_files_c_macros() {
  # C code macros
  echo "// Macros for feature flags in C code" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  for flag in "${flag_names[@]}"; do
    default=$(yq ".feature_flags[] | select(.name == $flag) | .default" "${FEATURE_FLAGS_DEFS_PATH}")
    description=$(yq ".feature_flags[] | select(.name == $flag) | .description" "${FEATURE_FLAGS_DEFS_PATH}")

    echo "// ${flag} - ${description}" >> "${FEATURE_FLAGS_CXX_PATH}"

    # make uppercase and strip quotes
    flag=$(strip_quotes "${flag}")
    flag_upper=$(convert_to_upper_case "${flag}")

    if [[ ${CONFIGURE_FEATURE_FLAGS[$flag]} == true ]]; then
      echo "#define FEATURE_FLAG_${flag_upper} 1" >> "${FEATURE_FLAGS_CXX_PATH}"
    else
      echo "#define FEATURE_FLAG_${flag_upper} 0" >> "${FEATURE_FLAGS_CXX_PATH}"
    fi

    echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  done

  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  echo "// =========================================================================================" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_generate_cxx_files_enums() {
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  # Prepare enum for C++ code
  echo "enum class FeatureFlag {" >> "${FEATURE_FLAGS_CXX_PATH}"
  for flag in "${flag_names[@]}"; do
    flag=$(strip_quotes "${flag}")
    local flag_pascal
    flag_pascal=$(snake_case_to_pascal_case "${flag}")

    echo "    k${flag_pascal}," >> "${FEATURE_FLAGS_CXX_PATH}"
  done
  echo "    kLast," >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "};" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_generate_cxx_files_cxx_vars() {
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  # Prepare constexpr variable for C++ code
  echo "template <FeatureFlag Flag>" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "constexpr bool FeatureEnabled = false;" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  for flag in "${flag_names[@]}"; do
    default=$(yq ".feature_flags[] | select(.name == $flag) | .default" "${FEATURE_FLAGS_DEFS_PATH}")
    description=$(yq ".feature_flags[] | select(.name == $flag) | .description" "${FEATURE_FLAGS_DEFS_PATH}")

    echo "// ${flag} - ${description}" >> "${FEATURE_FLAGS_CXX_PATH}"

    flag=$(strip_quotes "${flag}")
    local flag_pascal
    flag_pascal=$(snake_case_to_pascal_case "${flag}")

    if [[ ${CONFIGURE_FEATURE_FLAGS[$flag]} == true ]]; then
      echo "template <> constexpr bool FeatureEnabled<FeatureFlag::k${flag_pascal}> = true;" >> "${FEATURE_FLAGS_CXX_PATH}"
    else
      echo "template <> constexpr bool FeatureEnabled<FeatureFlag::k${flag_pascal}> = false;" >> "${FEATURE_FLAGS_CXX_PATH}"
    fi

    echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  done
}

feature_flags_generate_cxx_files() {
  # Source the feature flags to load existing flags
  source "${FEATURE_FLAGS_PATH}"

  # Remove old header
  rm -f "${FEATURE_FLAGS_CXX_PATH}"
  touch "${FEATURE_FLAGS_CXX_PATH}"

  feature_flags_generate_cxx_files_header
  feature_flags_generate_cxx_files_c_macros

  # C++ code
  echo "#ifdef __cplusplus" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "// Code for feature flags in C++ code" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  feature_flags_generate_cxx_files_enums
  feature_flags_generate_cxx_files_cxx_vars

  # Close the C++ code section
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#endif // __cplusplus" >> "${FEATURE_FLAGS_CXX_PATH}"

  # Close the header guard
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#endif // GENERATED_INCLUDE_AUTOGEN_H_" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_process() {
  if [[ ! -f "${FEATURE_FLAGS_PATH}" ]]; then
    feature_flags_generate_file
  fi

  # Source the feature flags to load existing flags
  source "${FEATURE_FLAGS_PATH}"

  if ! grep -q "declare -A CONFIGURE_FEATURE_FLAGS" "${FEATURE_FLAGS_PATH}"; then
    dump_error "Feature flags file is not correctly formatted. Delete existing file and re-run the script."
    exit 1
  fi

  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  # Add each missing flag to the feature flags file
  for flag in "${flag_names[@]}"; do
    if ! grep -q "CONFIGURE_FEATURE_FLAGS\[${flag}\]=" "${FEATURE_FLAGS_PATH}"; then
      default=$(yq ".feature_flags[] | select(.name == $flag) | .default" "${FEATURE_FLAGS_DEFS_PATH}")
      description=$(yq ".feature_flags[] | select(.name == $flag) | .description" "${FEATURE_FLAGS_DEFS_PATH}")

      echo "# ${flag} - ${description}" >> "${FEATURE_FLAGS_PATH}"
      echo "CONFIGURE_FEATURE_FLAGS[${flag}]=${default}" >> "${FEATURE_FLAGS_PATH}"
      echo "" >> "${FEATURE_FLAGS_PATH}"
    fi
  done

  # Source the updated feature flags file
  source "${FEATURE_FLAGS_PATH}"

  # Verify structure of config file
  for flag in "${!CONFIGURE_FEATURE_FLAGS[@]}"; do
    # Check if flag from file is in definitions
    if ! printf '%s\n' "${flag_names[@]}" | grep -q ${flag}; then
        pretty_warn "Feature flag ${flag} is unrecognized. Please check your feature flags definitions."
    fi
  done

  # Generate CXX feature flag files
  feature_flags_generate_cxx_files
}

feature_flags_generate_cmake() {
  # Source the feature flags to load existing flags
  source "${FEATURE_FLAGS_PATH}"

  local conf_cmake="${FEATURE_FLAGS_DIR}/../../config/conf.generated.cmake"

  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  echo "" >> "$conf_cmake"
  echo "# FEATURE FLAGS: " >> "$conf_cmake"
  for flag in "${flag_names[@]}"; do
    # make first letter uppercase and replace underscores with big letters
    flag=$(echo "${flag}" | tr -d '"')
    flag_upper=$(convert_to_upper_case "${flag}")

    if [[ ${CONFIGURE_FEATURE_FLAGS[$flag]} == true ]]; then
      echo "set(CMAKE_FEATURE_FLAG_${flag_upper} ON)" >> "${conf_cmake}"
    else
      echo "set(CMAKE_FEATURE_FLAG_${flag_upper} OFF)" >> "${conf_cmake}"
    fi
  done
}

# ------------------------------
# Usage functionality
# ------------------------------

feature_flags_set() {
  assert_argument_provided "$1"
  assert_argument_provided "$2"
  local flag_name="$1"
  local flag_value="$2"

  if [[ -z "${CONFIGURE_FEATURE_FLAGS[$flag_name]}" ]]; then
    dump_error "Feature flag '${flag_name}' is not defined."
    return 1
  fi

  if [[ "$flag_value" != "true" && "$flag_value" != "false" ]]; then
    dump_error "Invalid value for feature flag '${flag_name}'. Use 'true' or 'false'."
    return 1
  fi

  CONFIGURE_FEATURE_FLAGS[$flag_name]="$flag_value"

  # Inline replace the file with the new value
  sed -i.bak "s/^CONFIGURE_FEATURE_FLAGS\[$flag_name\]=.*/CONFIGURE_FEATURE_FLAGS[$flag_name]=$flag_value/" "${FEATURE_FLAGS_PATH}"
}

feature_flags_get() {
  assert_argument_provided "$1"
  local flag_name="$1"

  if [[ -z "${CONFIGURE_FEATURE_FLAGS[$flag_name]}" ]]; then
    dump_error "Feature flag '${flag_name}' is not defined."
    return 1
  fi

  echo "${CONFIGURE_FEATURE_FLAGS[$flag_name]}"
}
