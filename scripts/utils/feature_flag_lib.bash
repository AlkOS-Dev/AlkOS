#!/bin/bash

FEATURE_FLAGS_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
FEATURE_FLAGS_PATH="${FEATURE_FLAGS_DIR}/../../config/feature_flags_config.yaml"
FEATURE_FLAGS_DEFS_PATH="${FEATURE_FLAGS_DIR}/../config/feature_flags_schema.yaml"
FEATURE_FLAGS_CXX_PATH="${FEATURE_FLAGS_DIR}/../../generated/include/autogen/feature_flags.h"

source "${FEATURE_FLAGS_DIR}/helpers.bash"

declare -A CONFIGURE_FEATURE_FLAGS

# --------------------------------------------
# Helper functions for YAML handling
# --------------------------------------------

load_feature_flags_from_yaml() {
  if [[ -f "${FEATURE_FLAGS_PATH}" ]]; then
    local flag_names
    mapfile -t flag_names < <(yq '.feature_flags | keys[]' "${FEATURE_FLAGS_PATH}" 2>/dev/null || echo "")

    for flag in "${flag_names[@]}"; do
      local value
      value=$(yq ".feature_flags.${flag}" "${FEATURE_FLAGS_PATH}" 2>/dev/null)
      flag=$(strip_quotes "${flag}")

      if [[ -n "$value" && "$value" != "null" ]]; then
        CONFIGURE_FEATURE_FLAGS["$flag"]="$value"
      fi
    done
  fi
}

save_feature_flags_to_yaml() {
  cat > "${FEATURE_FLAGS_PATH}" << 'EOF'
# Feature flags configuration - rerun configure script to update the build system
feature_flags:
EOF

  # Get flag names from definitions to maintain order and get descriptions
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  for flag in "${flag_names[@]}"; do
    flag=$(strip_quotes "${flag}")
    if [[ -n "${CONFIGURE_FEATURE_FLAGS["$flag"]}" ]]; then
      local description
      description=$(yq ".feature_flags[] | select(.name == \"$flag\") | .description" "${FEATURE_FLAGS_DEFS_PATH}")
      description=$(strip_quotes "${description}")

      echo "" >> "${FEATURE_FLAGS_PATH}"
      echo "  # ${description}" >> "${FEATURE_FLAGS_PATH}"
      echo "  ${flag}: ${CONFIGURE_FEATURE_FLAGS[$flag]}" >> "${FEATURE_FLAGS_PATH}"
    fi
  done
}

# --------------------------------------------
# Helper functions for flag validation
# --------------------------------------------

get_flag_type() {
  local flag=$1
  local type
  type=$(yq ".feature_flags[] | select(.name == \"$flag\") | .type" "${FEATURE_FLAGS_DEFS_PATH}" 2>/dev/null)
  type=$(strip_quotes "${type}")

  # Default to boolean if type is not specified
  if [[ -z "$type" || "$type" == "null" ]]; then
    echo "boolean"
  else
    echo "$type"
  fi
}

validate_flag_value() {
  local flag=$1
  local value=$2
  local type
  type=$(get_flag_type "$flag")

  case "$type" in
    boolean)
      if [[ "$value" != "true" && "$value" != "false" ]]; then
        return 1
      fi
      ;;
    integer)
      # Check if value is an integer
      if ! [[ "$value" =~ ^-?[0-9]+$ ]]; then
        return 1
      fi

      # Check min constraint
      local min
      min=$(yq ".feature_flags[] | select(.name == \"$flag\") | .min" "${FEATURE_FLAGS_DEFS_PATH}" 2>/dev/null)
      if [[ -n "$min" && "$min" != "null" ]]; then
        if (( value < min )); then
          dump_error "Value $value is below minimum $min for flag $flag"
          return 1
        fi
      fi

      # Check max constraint
      local max
      max=$(yq ".feature_flags[] | select(.name == \"$flag\") | .max" "${FEATURE_FLAGS_DEFS_PATH}" 2>/dev/null)
      if [[ -n "$max" && "$max" != "null" ]]; then
        if (( value > max )); then
          dump_error "Value $value exceeds maximum $max for flag $flag"
          return 1
        fi
      fi
      ;;
    *)
      dump_error "Unknown type '$type' for flag $flag"
      return 1
      ;;
  esac

  return 0
}

# --------------------------------------------
# Feature flags generation functionality
# --------------------------------------------

feature_flags_generate_file() {
  cat > "${FEATURE_FLAGS_PATH}" << 'EOF'
# Feature flags configuration - rerun configure script to update the build system
# This file is generated by the configure script
feature_flags: {}
EOF
}

feature_flags_generate_cxx_files_header() {
  echo "// This file is generated by configure script. Do not edit manually." > "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#ifndef GENERATED_INCLUDE_AUTOGEN_H_" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#define GENERATED_INCLUDE_AUTOGEN_H_" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_generate_cxx_files_c_macros() {
  # C code macros
  echo "// Macros for feature flags in C code" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  for flag in "${flag_names[@]}"; do
    default=$(yq ".feature_flags[] | select(.name == $flag) | .default" "${FEATURE_FLAGS_DEFS_PATH}")
    description=$(yq ".feature_flags[] | select(.name == $flag) | .description" "${FEATURE_FLAGS_DEFS_PATH}")

    echo "// ${flag} - ${description}" >> "${FEATURE_FLAGS_CXX_PATH}"

    # make uppercase and strip quotes
    flag=$(strip_quotes "${flag}")
    flag_upper=$(convert_to_upper_case "${flag}")

    local type
    type=$(get_flag_type "$flag")

    if [[ "$type" == "boolean" ]]; then
      if [[ ${CONFIGURE_FEATURE_FLAGS[$flag]} == true ]]; then
        echo "#define FEATURE_FLAG_${flag_upper} 1" >> "${FEATURE_FLAGS_CXX_PATH}"
      else
        echo "#define FEATURE_FLAG_${flag_upper} 0" >> "${FEATURE_FLAGS_CXX_PATH}"
      fi
    else
      echo "#define FEATURE_FLAG_${flag_upper} ${CONFIGURE_FEATURE_FLAGS[$flag]}" >> "${FEATURE_FLAGS_CXX_PATH}"
    fi

    echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  done

  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  echo "// =========================================================================================" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_generate_cxx_files_enums() {
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  # Prepare enum for C++ code
  echo "enum class FeatureFlag {" >> "${FEATURE_FLAGS_CXX_PATH}"
  for flag in "${flag_names[@]}"; do
    flag=$(strip_quotes "${flag}")
    local flag_pascal
    flag_pascal=$(snake_case_to_pascal_case "${flag}")

    echo "    k${flag_pascal}," >> "${FEATURE_FLAGS_CXX_PATH}"
  done
  echo "    kLast," >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "};" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_generate_cxx_files_cxx_vars() {
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  # Separate boolean and integer flags
  local bool_flags=()
  local int_flags=()

  for flag in "${flag_names[@]}"; do
    flag=$(strip_quotes "${flag}")
    local type
    type=$(get_flag_type "$flag")

    if [[ "$type" == "boolean" ]]; then
      bool_flags+=("$flag")
    else
      int_flags+=("$flag")
    fi
  done

  # Generate boolean flag template
  if [[ ${#bool_flags[@]} -gt 0 ]]; then
    echo "// Boolean feature flags" >> "${FEATURE_FLAGS_CXX_PATH}"
    echo "template <FeatureFlag Flag>" >> "${FEATURE_FLAGS_CXX_PATH}"
    echo "inline constexpr bool FeatureEnabled = false;" >> "${FEATURE_FLAGS_CXX_PATH}"
    echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

    for flag in "${bool_flags[@]}"; do
      default=$(yq ".feature_flags[] | select(.name == \"$flag\") | .default" "${FEATURE_FLAGS_DEFS_PATH}")
      description=$(yq ".feature_flags[] | select(.name == \"$flag\") | .description" "${FEATURE_FLAGS_DEFS_PATH}")

      echo "// ${flag} - ${description}" >> "${FEATURE_FLAGS_CXX_PATH}"

      local flag_pascal
      flag_pascal=$(snake_case_to_pascal_case "${flag}")

      if [[ ${CONFIGURE_FEATURE_FLAGS[$flag]} == true ]]; then
        echo "template <> inline constexpr bool FeatureEnabled<FeatureFlag::k${flag_pascal}> = true;" >> "${FEATURE_FLAGS_CXX_PATH}"
      else
        echo "template <> inline constexpr bool FeatureEnabled<FeatureFlag::k${flag_pascal}> = false;" >> "${FEATURE_FLAGS_CXX_PATH}"
      fi

      echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
    done
  fi

  # Generate integer flag template
  if [[ ${#int_flags[@]} -gt 0 ]]; then
    echo "// Integer feature flags" >> "${FEATURE_FLAGS_CXX_PATH}"
    echo "template <FeatureFlag Flag>" >> "${FEATURE_FLAGS_CXX_PATH}"
    echo "inline constexpr int FeatureValue = 0;" >> "${FEATURE_FLAGS_CXX_PATH}"
    echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

    for flag in "${int_flags[@]}"; do
      default=$(yq ".feature_flags[] | select(.name == \"$flag\") | .default" "${FEATURE_FLAGS_DEFS_PATH}")
      description=$(yq ".feature_flags[] | select(.name == \"$flag\") | .description" "${FEATURE_FLAGS_DEFS_PATH}")

      echo "// ${flag} - ${description}" >> "${FEATURE_FLAGS_CXX_PATH}"

      local flag_pascal
      flag_pascal=$(snake_case_to_pascal_case "${flag}")

      echo "template <> inline constexpr int FeatureValue<FeatureFlag::k${flag_pascal}> = ${CONFIGURE_FEATURE_FLAGS[$flag]};" >> "${FEATURE_FLAGS_CXX_PATH}"

      echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
    done
  fi
}

feature_flags_generate_cxx_files() {
  load_feature_flags_from_yaml

  # Remove old header
  mkdir -p "$(dirname "${FEATURE_FLAGS_CXX_PATH}")"
  rm -f "${FEATURE_FLAGS_CXX_PATH}"
  touch "${FEATURE_FLAGS_CXX_PATH}"

  feature_flags_generate_cxx_files_header
  feature_flags_generate_cxx_files_c_macros

  # C++ code
  echo "#ifdef __cplusplus" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "// Code for feature flags in C++ code" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  feature_flags_generate_cxx_files_enums
  feature_flags_generate_cxx_files_cxx_vars

  # Close the C++ code section
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#endif // __cplusplus" >> "${FEATURE_FLAGS_CXX_PATH}"

  # Close the header guard
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#endif // GENERATED_INCLUDE_AUTOGEN_H_" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_process() {
  if [[ ! -f "${FEATURE_FLAGS_PATH}" ]]; then
    feature_flags_generate_file
  fi

  load_feature_flags_from_yaml

  # Check if YAML file has correct structure
  if ! yq -e '.feature_flags' "${FEATURE_FLAGS_PATH}" >/dev/null 2>&1; then
    dump_error "Feature flags file is not correctly formatted. Delete existing file and re-run the script."
    exit 1
  fi

  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")
  local flags_updated=false

  # Add each missing flag to the feature flags
  for flag in ${flag_names[@]}; do
    flag=$(strip_quotes "${flag}")

    if [[ -z "${CONFIGURE_FEATURE_FLAGS[$flag]}" ]]; then
      default=$(yq ".feature_flags[] | select(.name == \"$flag\") | .default" "${FEATURE_FLAGS_DEFS_PATH}")
      description=$(yq ".feature_flags[] | select(.name == \"$flag\") | .description" "${FEATURE_FLAGS_DEFS_PATH}")

      CONFIGURE_FEATURE_FLAGS["$flag"]="$default"
      flags_updated=true
    fi
  done

  # Verify structure of config file
  for flag in "${!CONFIGURE_FEATURE_FLAGS[@]}"; do
    # Check if flag from file is in definitions
    local flag_exists=false
    for def_flag in "${flag_names[@]}"; do
      def_flag=$(strip_quotes "${def_flag}")
      if [[ "$flag" == "$def_flag" ]]; then
        flag_exists=true
        break
      fi
    done

    if [[ "$flag_exists" == false ]]; then
      pretty_warn "Feature flag ${flag} is unrecognized. Correcting to default."
    fi

    # Validate flag value based on type
    if ! validate_flag_value "$flag" "${CONFIGURE_FEATURE_FLAGS[$flag]}"; then
      pretty_warn "Feature flag ${flag} has invalid value ${CONFIGURE_FEATURE_FLAGS[$flag]}."
      default=$(yq ".feature_flags[] | select(.name == \"$flag\") | .default" "${FEATURE_FLAGS_DEFS_PATH}")
      CONFIGURE_FEATURE_FLAGS[$flag]="$default"
      flags_updated=true
    fi
  done

  if [[ "$flags_updated" == true ]]; then
    save_feature_flags_to_yaml
  fi
}

feature_flags_reset_to_defaults() {
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  for flag in "${flag_names[@]}"; do
    flag=$(strip_quotes "${flag}")
    default=$(yq ".feature_flags[] | select(.name == \"$flag\") | .default" "${FEATURE_FLAGS_DEFS_PATH}")
    CONFIGURE_FEATURE_FLAGS[$flag]="$default"
  done

  save_feature_flags_to_yaml
}

feature_flags_generate_cmake() {
  load_feature_flags_from_yaml

  local conf_cmake="${FEATURE_FLAGS_DIR}/../../config/conf.generated.cmake"

  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  echo "" >> "$conf_cmake"
  echo "# FEATURE FLAGS: " >> "$conf_cmake"
  for flag in "${flag_names[@]}"; do
    # make first letter uppercase and replace underscores with big letters
    flag=$(echo "${flag}" | tr -d '"')
    flag_upper=$(convert_to_upper_case "${flag}")

    local type
    type=$(get_flag_type "$flag")

    if [[ "$type" == "boolean" ]]; then
      if [[ ${CONFIGURE_FEATURE_FLAGS[$flag]} == true ]]; then
        echo "set(CMAKE_FEATURE_FLAG_${flag_upper} ON)" >> "${conf_cmake}"
      else
        echo "set(CMAKE_FEATURE_FLAG_${flag_upper} OFF)" >> "${conf_cmake}"
      fi
    else
      # For integer flags, set the actual value
      echo "set(CMAKE_FEATURE_FLAG_${flag_upper} ${CONFIGURE_FEATURE_FLAGS[$flag]})" >> "${conf_cmake}"
    fi
  done
}

# ------------------------------
# Usage functionality
# ------------------------------

feature_flags_set() {
  assert_argument_provided "$1"
  assert_argument_provided "$2"
  local flag_name=$1
  local flag_value=$2

  load_feature_flags_from_yaml

  if [[ -z "${CONFIGURE_FEATURE_FLAGS[$flag_name]}" ]]; then
    dump_error "Feature flag '${flag_name}' is not defined."
    return 1
  fi

  if ! validate_flag_value "$flag_name" "$flag_value"; then
    local type
    type=$(get_flag_type "$flag_name")
    if [[ "$type" == "boolean" ]]; then
      dump_error "Invalid value for feature flag '${flag_name}'. Use 'true' or 'false'."
    else
      dump_error "Invalid value for feature flag '${flag_name}'."
    fi
    return 1
  fi

  CONFIGURE_FEATURE_FLAGS[$flag_name]="$flag_value"

  save_feature_flags_to_yaml
}

feature_flags_get() {
  assert_argument_provided "$1"
  local flag_name=$1

  load_feature_flags_from_yaml

  if [[ -z "${CONFIGURE_FEATURE_FLAGS[$flag_name]}" ]]; then
    dump_error "Feature flag '${flag_name}' is not defined."
    return 1
  fi

  echo "${CONFIGURE_FEATURE_FLAGS[$flag_name]}"
}

feature_flags_apply_preset() {
  assert_argument_provided "$1"
  local preset="$1"

  # parse the preset string
  IFS=' ' read -ra flags <<< "$preset"
  for flag in "${flags[@]}"; do
    # Split flag into name and value
    IFS='=' read -r flag_name flag_value <<< "$flag"

    feature_flags_set $flag_name $flag_value
  done

  save_feature_flags_to_yaml
}
