#!/bin/bash

FEATURE_FLAGS_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
FEATURE_FLAGS_PATH="${FEATURE_FLAGS_DIR}/../../config/feature_flags_config.yaml"
FEATURE_FLAGS_DEFS_PATH="${FEATURE_FLAGS_DIR}/../config/feature_flags_schema.yaml"
FEATURE_FLAGS_CXX_PATH="${FEATURE_FLAGS_DIR}/../../alkos/generated/include/autogen/feature_flags.h"

source "${FEATURE_FLAGS_DIR}/helpers.bash"

declare -A CONFIGURE_FEATURE_FLAGS

# --------------------------------------------
# Helper functions for YAML handling
# --------------------------------------------

load_feature_flags_from_yaml() {
  if [[ -f "${FEATURE_FLAGS_PATH}" ]]; then
    local flag_names
    mapfile -t flag_names < <(yq '.feature_flags | keys[]' "${FEATURE_FLAGS_PATH}" 2>/dev/null || echo "")

    for flag in "${flag_names[@]}"; do
      local value
      value=$(yq ".feature_flags.${flag}" "${FEATURE_FLAGS_PATH}" 2>/dev/null)
      flag=$(strip_quotes "${flag}")

      if [[ -n "$value" && "$value" != "null" ]]; then
        CONFIGURE_FEATURE_FLAGS["$flag"]="$value"
      fi
    done
  fi
}

save_feature_flags_to_yaml() {
  cat > "${FEATURE_FLAGS_PATH}" << 'EOF'
# Feature flags configuration - rerun configure script to update the build system
feature_flags:
EOF

  # Get flag names from definitions to maintain order and get descriptions
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  for flag in "${flag_names[@]}"; do
    flag=$(strip_quotes "${flag}")
    if [[ -n "${CONFIGURE_FEATURE_FLAGS["$flag"]}" ]]; then
      local description
      description=$(yq ".feature_flags[] | select(.name == \"$flag\") | .description" "${FEATURE_FLAGS_DEFS_PATH}")
      description=$(strip_quotes "${description}")

      echo "" >> "${FEATURE_FLAGS_PATH}"
      echo "  # ${description}" >> "${FEATURE_FLAGS_PATH}"
      echo "  ${flag}: ${CONFIGURE_FEATURE_FLAGS[$flag]}" >> "${FEATURE_FLAGS_PATH}"
    fi
  done
}

# --------------------------------------------
# Feature flags generation functionality
# --------------------------------------------

feature_flags_generate_file() {
  cat > "${FEATURE_FLAGS_PATH}" << 'EOF'
# Feature flags configuration - rerun configure script to update the build system
# This file is generated by the configure script
feature_flags: {}
EOF
}

feature_flags_generate_cxx_files_header() {
  echo "// This file is generated by configure script. Do not edit manually." > "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#ifndef GENERATED_INCLUDE_AUTOGEN_H_" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#define GENERATED_INCLUDE_AUTOGEN_H_" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_generate_cxx_files_c_macros() {
  # C code macros
  echo "// Macros for feature flags in C code" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  for flag in "${flag_names[@]}"; do
    default=$(yq ".feature_flags[] | select(.name == $flag) | .default" "${FEATURE_FLAGS_DEFS_PATH}")
    description=$(yq ".feature_flags[] | select(.name == $flag) | .description" "${FEATURE_FLAGS_DEFS_PATH}")

    echo "// ${flag} - ${description}" >> "${FEATURE_FLAGS_CXX_PATH}"

    # make uppercase and strip quotes
    flag=$(strip_quotes "${flag}")
    flag_upper=$(convert_to_upper_case "${flag}")

    if [[ ${CONFIGURE_FEATURE_FLAGS[$flag]} == true ]]; then
      echo "#define FEATURE_FLAG_${flag_upper} 1" >> "${FEATURE_FLAGS_CXX_PATH}"
    else
      echo "#define FEATURE_FLAG_${flag_upper} 0" >> "${FEATURE_FLAGS_CXX_PATH}"
    fi

    echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  done

  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  echo "// =========================================================================================" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_generate_cxx_files_enums() {
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  # Prepare enum for C++ code
  echo "enum class FeatureFlag {" >> "${FEATURE_FLAGS_CXX_PATH}"
  for flag in "${flag_names[@]}"; do
    flag=$(strip_quotes "${flag}")
    local flag_pascal
    flag_pascal=$(snake_case_to_pascal_case "${flag}")

    echo "    k${flag_pascal}," >> "${FEATURE_FLAGS_CXX_PATH}"
  done
  echo "    kLast," >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "};" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_generate_cxx_files_cxx_vars() {
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  # Prepare constexpr variable for C++ code
  echo "template <FeatureFlag Flag>" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "constexpr bool FeatureEnabled = false;" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  for flag in "${flag_names[@]}"; do
    default=$(yq ".feature_flags[] | select(.name == $flag) | .default" "${FEATURE_FLAGS_DEFS_PATH}")
    description=$(yq ".feature_flags[] | select(.name == $flag) | .description" "${FEATURE_FLAGS_DEFS_PATH}")

    echo "// ${flag} - ${description}" >> "${FEATURE_FLAGS_CXX_PATH}"

    flag=$(strip_quotes "${flag}")
    local flag_pascal
    flag_pascal=$(snake_case_to_pascal_case "${flag}")

    if [[ ${CONFIGURE_FEATURE_FLAGS[$flag]} == true ]]; then
      echo "template <> constexpr bool FeatureEnabled<FeatureFlag::k${flag_pascal}> = true;" >> "${FEATURE_FLAGS_CXX_PATH}"
    else
      echo "template <> constexpr bool FeatureEnabled<FeatureFlag::k${flag_pascal}> = false;" >> "${FEATURE_FLAGS_CXX_PATH}"
    fi

    echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  done
}

feature_flags_generate_cxx_files() {
  load_feature_flags_from_yaml

  # Remove old header
  rm -f "${FEATURE_FLAGS_CXX_PATH}"
  touch "${FEATURE_FLAGS_CXX_PATH}"

  feature_flags_generate_cxx_files_header
  feature_flags_generate_cxx_files_c_macros

  # C++ code
  echo "#ifdef __cplusplus" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "// Code for feature flags in C++ code" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"

  feature_flags_generate_cxx_files_enums
  feature_flags_generate_cxx_files_cxx_vars

  # Close the C++ code section
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#endif // __cplusplus" >> "${FEATURE_FLAGS_CXX_PATH}"

  # Close the header guard
  echo "" >> "${FEATURE_FLAGS_CXX_PATH}"
  echo "#endif // GENERATED_INCLUDE_AUTOGEN_H_" >> "${FEATURE_FLAGS_CXX_PATH}"
}

feature_flags_process() {
  if [[ ! -f "${FEATURE_FLAGS_PATH}" ]]; then
    feature_flags_generate_file
  fi

  load_feature_flags_from_yaml

  # Check if YAML file has correct structure
  if ! yq -e '.feature_flags' "${FEATURE_FLAGS_PATH}" >/dev/null 2>&1; then
    dump_error "Feature flags file is not correctly formatted. Delete existing file and re-run the script."
    exit 1
  fi

  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")
  local flags_updated=false

  # Add each missing flag to the feature flags
  for flag in ${flag_names[@]}; do
    flag=$(strip_quotes "${flag}")

    if [[ -z "${CONFIGURE_FEATURE_FLAGS[$flag]}" ]]; then
      default=$(yq ".feature_flags[] | select(.name == \"$flag\") | .default" "${FEATURE_FLAGS_DEFS_PATH}")
      description=$(yq ".feature_flags[] | select(.name == \"$flag\") | .description" "${FEATURE_FLAGS_DEFS_PATH}")

      CONFIGURE_FEATURE_FLAGS["$flag"]="$default"
      flags_updated=true
    fi
  done

  # Verify structure of config file
  for flag in "${!CONFIGURE_FEATURE_FLAGS[@]}"; do
    # Check if flag from file is in definitions
    local flag_exists=false
    for def_flag in "${flag_names[@]}"; do
      def_flag=$(strip_quotes "${def_flag}")
      if [[ "$flag" == "$def_flag" ]]; then
        flag_exists=true
        break
      fi
    done

    if [[ "$flag_exists" == false ]]; then
      pretty_warn "Feature flag ${flag} is unrecognized. Correcting to default."
    fi

    # Validate if flag value is boolean
    if [[ "${CONFIGURE_FEATURE_FLAGS[$flag]}" != "true" && "${CONFIGURE_FEATURE_FLAGS[$flag]}" != "false" ]]; then
      pretty_warn "Feature flag ${flag} has invalid value ${CONFIGURE_FEATURE_FLAGS[$flag]}. Expected 'true' or 'false'."
      default=$(yq ".feature_flags[] | select(.name == \"$flag\") | .default" "${FEATURE_FLAGS_DEFS_PATH}")
      CONFIGURE_FEATURE_FLAGS[$flag]="$default"
      flags_updated=true
    fi
  done

    if [[ "$flags_updated" == true ]]; then
      save_feature_flags_to_yaml
    fi
}

feature_flags_reset_to_defaults() {
  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  for flag in "${flag_names[@]}"; do
    flag=$(strip_quotes "${flag}")
    default=$(yq ".feature_flags[] | select(.name == \"$flag\") | .default" "${FEATURE_FLAGS_DEFS_PATH}")
    CONFIGURE_FEATURE_FLAGS[$flag]="$default"
  done

  save_feature_flags_to_yaml
}

feature_flags_generate_cmake() {
  load_feature_flags_from_yaml

  local conf_cmake="${FEATURE_FLAGS_DIR}/../../config/conf.generated.cmake"

  local flag_names
  mapfile -t flag_names < <(yq '.feature_flags[].name' "${FEATURE_FLAGS_DEFS_PATH}")

  echo "" >> "$conf_cmake"
  echo "# FEATURE FLAGS: " >> "$conf_cmake"
  for flag in "${flag_names[@]}"; do
    # make first letter uppercase and replace underscores with big letters
    flag=$(echo "${flag}" | tr -d '"')
    flag_upper=$(convert_to_upper_case "${flag}")

    if [[ ${CONFIGURE_FEATURE_FLAGS[$flag]} == true ]]; then
      echo "set(CMAKE_FEATURE_FLAG_${flag_upper} ON)" >> "${conf_cmake}"
    else
      echo "set(CMAKE_FEATURE_FLAG_${flag_upper} OFF)" >> "${conf_cmake}"
    fi
  done
}

# ------------------------------
# Usage functionality
# ------------------------------

feature_flags_set() {
  assert_argument_provided "$1"
  assert_argument_provided "$2"
  local flag_name=$1
  local flag_value=$2

  load_feature_flags_from_yaml

  if [[ -z "${CONFIGURE_FEATURE_FLAGS[$flag_name]}" ]]; then
    dump_error "Feature flag '${flag_name}' is not defined."
    return 1
  fi

  if [[ "$flag_value" != "true" && "$flag_value" != "false" ]]; then
    dump_error "Invalid value for feature flag '${flag_name}'. Use 'true' or 'false'."
    return 1
  fi

  CONFIGURE_FEATURE_FLAGS[$flag_name]="$flag_value"

  save_feature_flags_to_yaml
}

feature_flags_get() {
  assert_argument_provided "$1"
  local flag_name=$1

  load_feature_flags_from_yaml

  if [[ -z "${CONFIGURE_FEATURE_FLAGS[$flag_name]}" ]]; then
    dump_error "Feature flag '${flag_name}' is not defined."
    return 1
  fi

  echo "${CONFIGURE_FEATURE_FLAGS[$flag_name]}"
}

feature_flags_apply_preset() {
  assert_argument_provided "$1"
  local preset="$1"

  # parse the preset string
  IFS=' ' read -ra flags <<< "$preset"
  for flag in "${flags[@]}"; do
    # Split flag into name and value
    IFS='=' read -r flag_name flag_value <<< "$flag"

    feature_flags_set $flag_name $flag_value
  done

  save_feature_flags_to_yaml
}
